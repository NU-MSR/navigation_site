<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-01-11 Thu 09:26 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CMake Basics</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Matthew Elwin">
<link rel="stylesheet" href="./../pubme.css" type="text/css"/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="./../index.html"> HOME </a>
</div><div id="content">
<header>
<h1 class="title">CMake Basics</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc9f87bf">Overview</a></li>
<li><a href="#org08e180d">Compilation Process Overview</a></li>
<li><a href="#org83cfdc6">What is CMake?</a>
<ul>
<li><a href="#org10c3ac2">Why do we need build tools?</a></li>
</ul>
</li>
<li><a href="#org6781519">Basics</a>
<ul>
<li><a href="#org64c3778">File Layout</a></li>
<li><a href="#org6c7f83e">Basic CMakeLists.txt</a></li>
<li><a href="#orgde65288">Doxygen</a></li>
<li><a href="#orgb320a44">Unit Testing</a></li>
<li><a href="#org3c393e4">Advanced Installation</a></li>
<li><a href="#org879bd17">Out-Of-Source Builds</a></li>
<li><a href="#org8e7afff">CMake Variables</a></li>
<li><a href="#orgb8d6042">Important CMake Concepts</a></li>
<li><a href="#orgda73c50">Basic CMake Syntax</a></li>
<li><a href="#org2e567a5">Dependencies</a></li>
</ul>
</li>
<li><a href="#orgfffa451">Useful compile options</a>
<ul>
<li><a href="#org6254e92">Local vs Global</a>
<ul>
<li><a href="#orgdfb3022">A Compromise Approach</a></li>
</ul>
</li>
<li><a href="#org6a6cd95">C++ Standard</a>
<ul>
<li><a href="#org6967f79">Locally (Per-Target)</a></li>
<li><a href="#orgda44306">Globally (all targets)</a></li>
<li><a href="#org089d7b9">Standards And ROS</a></li>
</ul>
</li>
<li><a href="#org86510c1">Compile Options</a>
<ul>
<li><a href="#orgb07ad4f">Locally (Per-Target)</a></li>
<li><a href="#orgcdd7ff9">Globally (all targets)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org29d77e2">Relationship with ament and colcon</a>
<ul>
<li><a href="#org320d6d0">Installation of ament_libraries</a></li>
</ul>
</li>
<li><a href="#orgd1386a8">ROS IDL Generation</a></li>
<li><a href="#org7ed96f0">Types of build</a></li>
<li><a href="#org35b39ac">CMake Practices</a></li>
<li><a href="#orgfb07ef6">Build Process as Directed Acyclic Graph</a></li>
<li><a href="#org050d0ca">Cross Compilation</a></li>
<li><a href="#orgd55453e">ROS 1 and Catkin</a>
<ul>
<li><a href="#orgd6649ab">A Deep Dive into a Catkin CMakeLists.txt</a></li>
</ul>
</li>
<li><a href="#org5c1043a">Resources</a></li>
</ul>
</div>
</nav>
<div id="outline-container-orgc9f87bf" class="outline-2">
<h2 id="orgc9f87bf">Overview</h2>
<div class="outline-text-2" id="text-orgc9f87bf">
<p>
This document explains the C++ build process, CMake, and colcon.
It is meant as a practical and somewhat minimal guide targeted at users of ROS who
have some experience with C++. For a broader overview of ROS packages/colcon see <a href="../../ros_notes/ros2">Colcon Notes</a>
</p>
</div>
</div>

<div id="outline-container-org08e180d" class="outline-2">
<h2 id="org08e180d">Compilation Process Overview</h2>
<div class="outline-text-2" id="text-org08e180d">
<ol class="org-ol">
<li>The C++ compilation process follows the same model as the C compilation process
<code>preprocess -&gt; compile -&gt; assemble -&gt; link</code></li>
<li>Compilation lets you do the hard work of translating human-readable source code into
machine code once upfront.</li>
<li>We will use the GNU C++ compiler gcc. Another popular choice on Linux is clang
<ul class="org-ul">
<li>You can install <code>clang</code> on Ubuntu as well</li>
<li>clang generally takes the same command line arguments as gcc. Compile-time errors are explained using different
language than with gcc so sometimes compiling with both compilers can help you track down an error more easily.</li>
<li>The output of <code>gcc</code> is generally considered to be faster, although <code>clang</code> is closing the gap</li>
</ul></li>
<li>Basic command-line: <code>g++ -o output_file -Wall -Wext -Wpedantic -std=c++17 file1.cpp file2.cpp</code>
<ul class="org-ul">
<li><code>-Wall</code> turns on all warnings.  These help you avoid errors so always use them.</li>
<li><code>-Wext</code> turns on extra warnings. These help you avoid errors so always use them.</li>
<li><code>-Wpedantic</code> turns on warnings related to conformance with the standard. This helps ensure your code will work with multiple compilers.</li>
<li><code>-std=c++17</code> lets you use C++17 features, which are great.</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org83cfdc6" class="outline-2">
<h2 id="org83cfdc6">What is CMake?</h2>
<div class="outline-text-2" id="text-org83cfdc6">
<ul class="org-ul">
<li><a href="https://cmake.org">CMake</a> is a cross-platform scripting language primarily used to <i>generate</i> instructions that other build tools
(such as Make, Ninja, Xcode, or Microsoft Visual Studio) can use to compile your program.</li>
<li>CMake is responsible for finding all system libraries and dependencies, determining which files constitute which executables and libraries,
managing compile flags, and determining which files go where upon installation.</li>
<li>Although other tools exist, CMake is a popular choice for building C++ projects and is almost becoming a defacto <a href="https://xkcd.com/927">standard</a>.</li>
</ul>
</div>

<div id="outline-container-org10c3ac2" class="outline-3">
<h3 id="org10c3ac2">Why do we need build tools?</h3>
<div class="outline-text-3" id="text-org10c3ac2">
<ol class="org-ol">
<li>Non-trivial C++ projects require the use of multiple source files and libraries that all must be combined together
<ul class="org-ul">
<li>Libraries may be located in different locations on different people's computers</li>
<li>People may want to use different compilers with different types of compiler options</li>
<li>People may want to customize your program by selecting different options at compile time</li>
<li>You may want someone to be able to run their code on a different operating system (not us) or even a computer with a different system architecture system (definitely us)</li>
</ul></li>
<li>There are also a large number of options that affect the behavior of the compiler that need to be managed</li>
<li>Without a build tools, you would have to manually enter the commands to compile the program
<ul class="org-ul">
<li>And not just you, everyone who wants to use your code</li>
</ul></li>
</ol>
<p>
4.The ideal of a working project is to have your code be able to compile and do all setup related steps in a single command
</p>
<ul class="org-ul">
<li>Computers are good at automating repetitive and tedious tasks!</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6781519" class="outline-2">
<h2 id="org6781519">Basics</h2>
<div class="outline-text-2" id="text-org6781519">
</div>
<div id="outline-container-org64c3778" class="outline-3">
<h3 id="org64c3778">File Layout</h3>
<div class="outline-text-3" id="text-org64c3778">
<ul class="org-ul">
<li>While there is no mandated file layout, there are common best practices.</li>
<li>the below structure is an example for a project called <code>project_name</code>.</li>
<li>The project creates a library called <code>mylibrary</code> and an executable called <code>Name</code>.</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">project_name
&#9500;&#9472;&#9472; CMakeLists.txt
&#9500;&#9472;&#9472; include
&#9474;&#160;&#160; &#9492;&#9472;&#9472; mylibrary
&#9474;&#160;&#160;     &#9492;&#9472;&#9472; header.hpp
&#9500;&#9472;&#9472; src
&#9474;   &#9500;&#9472;&#9472; libfile1.cpp
&#9474;   &#9500;&#9472;&#9472; libfile2.cpp
&#9474;   &#9492;&#9472;&#9472; Name_main.cpp
&#9492;&#9472;&#9472; tests
    &#9492;&#9472;&#9472; mytest.cpp
</pre>
</div>
<ol class="org-ol">
<li>All <code>CMake</code> projects have a <code>CMakeLists.txt</code> in the base directory.
<ul class="org-ul">
<li>This file is the primary file used to setup the build system.</li>
</ul></li>
<li><code>CMakeLists.txt</code> is responsible for:
<ul class="org-ul">
<li>Finding build dependencies of the project.</li>
<li>Determining compile options.</li>
<li>Determining what files must be compiled to create the libraries and executables produced by the project.</li>
<li>Providing instructions for how to install the libraries and executables.</li>
</ul></li>
<li>The <code>include/mylibrary</code> directory is there so that every project using the library can include headers by doing <code>#include"mylibrary/header.hpp"</code>
<ul class="org-ul">
<li>The project is setup to search for include files in <code>include/</code>. The directory structure means that the files themselves are under <code>mylibrary/header.hpp</code></li>
</ul></li>
<li>The <code>tests</code> directory holds the unit tests</li>
<li>Overall, as the project becomes more complex you may add more directories
<ul class="org-ul">
<li>In this example, we keep all <code>.cpp</code> files under <code>src</code> but other projects could do it differently by, for example, splitting the locations of library <code>.cpp</code> files and executable <code>.cpp</code> files</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org6c7f83e" class="outline-3">
<h3 id="org6c7f83e">Basic CMakeLists.txt</h3>
<div class="outline-text-3" id="text-org6c7f83e">
<ol class="org-ol">
<li><p>
Below is a template for <code>CMakeLists.txt</code> as well as comments describing each aspect
</p>
<div class="org-src-container">
<pre class="src src-cmake" id="org1c89df7"><span class="org-comment"># Lines that begin with a # are comments</span>
<span class="org-comment"># set the minimum required version of cmake, usually the first line</span>
<span class="org-function-name">cmake_minimum_required</span>(VERSION 3.22)

<span class="org-comment"># project_name sets the name of the project and causes cmake to</span>
<span class="org-comment"># find the c and c++ compilers</span>
<span class="org-function-name">project</span>(project_name)

<span class="org-comment"># Find your dependencies.</span>
<span class="org-comment"># Many libraries ship with files that allow CMake to find them</span>
<span class="org-comment"># Then general behavior is to call "find_package" but the options</span>
<span class="org-comment"># provided are package specific.  Usually there is then a CMAKE variable</span>
<span class="org-comment"># That is defined to reference the library</span>
<span class="org-comment"># here: we find the eigen library as per the instruction</span>
<span class="org-comment"># https://eigen.tuxfamily.org/dox/TopicCMakeGuide.html</span>
<span class="org-function-name">find_package</span>(Eigen3 3.3 REQUIRED NO_MODULE)

<span class="org-comment"># Create a library.  Can specify if it is shared or static but usually</span>
<span class="org-comment"># you don't need or want to.</span>
<span class="org-comment"># name is the name of the library without the extension or lib prefix</span>
<span class="org-comment"># name creates a cmake "target"</span>
<span class="org-function-name">add_library</span>(libname src/libfile1.cpp src/libfile2.cpp)

<span class="org-comment"># Use target_include_directories so that #include"mylibrary/header.hpp" works</span>
<span class="org-comment"># The use of the &lt;BUILD_INTERFACE&gt; and &lt;INSTALL_INTERFACE&gt; is because when</span>
<span class="org-comment"># Using the library from the build directory or after installation</span>
<span class="org-comment"># During build, the headers are read from the source code directory</span>
<span class="org-comment"># When used from the installed location, headers are in the</span>
<span class="org-comment"># system include/ directory</span>
<span class="org-function-name">target_include_directories</span>(libname
    PUBLIC
    $&lt;BUILD_INTERFACE:${<span class="org-variable-name">CMAKE_CURRENT_SOURCE_DIR</span>}/include/&gt;
    $&lt;INSTALL_INTERFACE:include/&gt;)

<span class="org-comment"># specify additional compilation flags for the library</span>
<span class="org-comment"># Public causes the flags to propagate to anything</span>
<span class="org-comment"># that links against this library</span>
<span class="org-function-name">target_compile_options</span>(libname PUBLIC -Wall -Wextra -pedantic)

<span class="org-comment"># Enable c++17 support.</span>
<span class="org-comment"># Public causes the features to propagate to anything</span>
<span class="org-comment"># that links against this library</span>
<span class="org-function-name">target_compile_features</span>(libname PUBLIC cxx_std_17)

<span class="org-comment"># Create an executable from the following source code files</span>
<span class="org-comment"># The Name of the executable creates a cmake "target"</span>
<span class="org-function-name">add_executable</span>(Name src/Name_main.cpp)

<span class="org-comment"># Use target_link_libraries to add dependencies to a "target"</span>
<span class="org-comment"># (e.g., a library or executable)</span>
<span class="org-comment"># This will automatically add all required library files</span>
<span class="org-comment"># that need to be linked</span>
<span class="org-comment"># and paths to th locations of header files</span>
<span class="org-function-name">target_link_libraries</span>(Name Eigen3::Eigen libname)

<span class="org-comment"># install the include files by copying the whole include directory</span>
<span class="org-function-name">install</span>(DIRECTORY include/mylibrary DESTINATION include)

<span class="org-comment"># Create a CMake Exported Target containing the lib and exe.</span>
<span class="org-comment"># Also create CMake Export called projet_name-targets</span>
<span class="org-comment"># The CMake Export contains files that allow other CMake projects</span>
<span class="org-comment"># to find this project. It must be installed separately.</span>
<span class="org-function-name">install</span>(TARGETS Name libname EXPORT project_name-targets)

<span class="org-comment"># The project_name-targets created by install(TARGETS) needs to be installed.</span>
<span class="org-comment"># install(EXPORT ...) will generate a file called project_name-config.cmake</span>
<span class="org-comment"># that contains the exported targets.</span>
<span class="org-comment"># After installation this file will then be found when calling</span>
<span class="org-comment"># find_package(project_name) from another cmake project</span>
<span class="org-comment"># A user can then target_link_libraries(target project_name::library)</span>
<span class="org-comment"># to use the libraries installed here</span>
<span class="org-function-name">install</span>(EXPORT project_name-targets
        FILE project_name-config.cmake
        NAMESPACE project_name::
        DESTINATION lib/cmake/${<span class="org-variable-name">PROJECT_NAME</span>})
</pre>
</div></li>

<li><p>
After writing a <code>CMakeLists.txt</code> configure the project and build it.
</p>
<div class="org-src-container">
<pre class="src src-bash">cmake -B build .
cmake --build build
</pre>
</div></li>

<li><p>
The above commands are equivalent to the following:
</p>
<div class="org-src-container">
<pre class="src src-bash">mkdir build
<span class="org-builtin">cd</span> build
cmake ..
make
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orgde65288" class="outline-3">
<h3 id="orgde65288">Doxygen</h3>
<div class="outline-text-3" id="text-orgde65288">
<p>
CMake has the ability to generate doxygen documentation automatically during the build
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">find_package</span>(Doxygen)

<span class="org-comment"># Building documentation should be optional.</span>
<span class="org-comment"># To build documentation pass -DBUILD_DOCS=ON when generating the build system</span>
<span class="org-function-name">option</span>(BUILD_DOCS <span class="org-string">"Build the documentation"</span> OFF)

<span class="org-comment"># build just because Doxygen is missing</span>
<span class="org-keyword">if</span>(${<span class="org-variable-name">DOXYGEN_FOUND</span>} AND ${<span class="org-variable-name">BUILD_DOCS</span>})
    <span class="org-comment"># Turn the README.md into the homepage of the doxygen docs</span>
    <span class="org-function-name">set</span>(DOXYGEN_USE_MDFILE_AS_MAINPAGE README.md)

    <span class="org-comment"># Tell Doxygen where to find the documentation</span>
    <span class="org-function-name">doxygen_add_docs</span>(doxygen include/ src/ README.md ALL)

    <span class="org-comment"># The documentation will be in the build/html directory</span>
    <span class="org-comment"># The main page is build/html/index.html</span>
<span class="org-keyword">endif</span>()
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb320a44" class="outline-3">
<h3 id="orgb320a44">Unit Testing</h3>
<div class="outline-text-3" id="text-orgb320a44">
<p>
CMake provides a framework for calling unit tests called <a href="https://cmake.org/cmake/help/latest/module/CTest.html">CTest</a> that enables coordinating tests with
the build system in a testing-framework agnostic manner
</p>

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">include</span>(CTest)

<span class="org-comment"># CTest sets BUILD_TESTING to on. To disable tests add -DBUILD_TESTING=OFF when invoking cmake</span>
<span class="org-keyword">if</span>(BUILD_TESTING)
    <span class="org-comment"># Find the Unit testing framework. In this example, Catch2</span>
    <span class="org-function-name">find_package</span>(Catch2 3 REQUIRED)

    <span class="org-comment"># A test is just an executable that is linked against the unit testing library</span>
    <span class="org-function-name">add_executable</span>(my_test_exe tests/mytest.cpp)
    <span class="org-function-name">target_link_libraries</span>(my_test_exe Catch2::Catch2WithMain AnyOtherLibrariesAsNeeded)

    <span class="org-comment"># register the test with CTest, telling it what executable to run</span>
    <span class="org-function-name">add_test</span>(NAME the_test_name COMMAND my_test_exe)
<span class="org-keyword">endif</span>()
</pre>
</div>

<p>
To run the tests, enter the <code>build/</code> directory and run <code>ctest --verbose</code>.
</p>
</div>
</div>
<div id="outline-container-org3c393e4" class="outline-3">
<h3 id="org3c393e4">Advanced Installation</h3>
<div class="outline-text-3" id="text-org3c393e4">
<ul class="org-ul">
<li>If a library that you write had dependencies, sometimes the users of your library
will also need these dependencies.</li>
<li>In this case, you can provide a custom <code>project_name-config.cmake</code> file that
automatically finds the required dependencies when <code>find_package</code> is called.</li>
<li>Rather than making the exports file the <code>project_name-config.cmake</code> that is run when <code>find_package</code> is called,
We instead install the exports file as <code>project_name-targets.cmake</code>.  We then create and install a custom file
that finds the dependencies and then includes the exports file.</li>

<li><p>
Here is an example <code>CMakeLists.txt</code> snippet.
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">install</span>(DIRECTORY include/mylibrary DESTINATION include)

<span class="org-function-name">install</span>(TARGETS Name libname EXPORT project_name-targets)

<span class="org-function-name">install</span>(EXPORT project_name-targets
         FILE project_name-targets.cmake
         NAMESPACE project_name::
         DESTINATION lib/cmake/${<span class="org-variable-name">PROJECT_NAME</span>})

<span class="org-function-name">configure_file</span>(project_name-config.cmake.in project_name-config.cmake @ONLY)
<span class="org-function-name">install</span>(FILES ${<span class="org-variable-name">CMAKE_CURRENT_BINARY_DIR</span>}/project_name-config.cmake
        DESTINATION lib/cmake/${<span class="org-variable-name">PROJECT_NAME</span>})
</pre>
</div></li>
<li>The <code>install(EXPORT)</code> now creates a file called <code>project_name-targets.cmake</code>
which contains the <code>exported</code> targets</li>
<li><p>
You now provide a file called <code>project_name-config.cmake.in</code> with the following contents
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-comment"># You can access variables from CMake by using the</span>
<span class="org-comment"># @var_name@ syntax. These variables will be replaced with there value</span>
<span class="org-comment"># from the current CMake session (useful for configuration)</span>
<span class="org-function-name">include</span>(CMakeFindDependencyMacro)
<span class="org-function-name">find_dependency</span>(a_dep_your_library_needs REQUIRED)

<span class="org-comment"># Once all dependencies are found, include the exported targets</span>
<span class="org-comment"># We expect that the project_name-targets.cmake file is installed</span>
<span class="org-comment"># next to project_name-config.cmake (this file)</span>
<span class="org-function-name">include</span>(${<span class="org-variable-name">CMAKE_CURRENT_LIST_DIR</span>}/project_name-targets.cmake)
</pre>
</div></li>
</ul>
</div>
</div>



<div id="outline-container-org879bd17" class="outline-3">
<h3 id="org879bd17">Out-Of-Source Builds</h3>
<div class="outline-text-3" id="text-org879bd17">
<ul class="org-ul">
<li>Notice that we created a build directory outside our source directory
<ul class="org-ul">
<li>This is known as an out-of-source build.</li>
<li>It is recommended to do out-of-source builds to avoid scattering
a bunch of files generated by CMake everywhere in your source tree
(a <code>.gitignore</code> nightmare!)</li>
<li>It is possible to invoke cmake in the same directory as the source code, which makes a mess</li>
<li><p>
I use the following code to prevent me from accidently doing that
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-keyword">if</span>(${<span class="org-variable-name">CMAKE_SOURCE_DIR</span>} STREQUAL ${<span class="org-variable-name">CMAKE_BINARY_DIR</span>})
    <span class="org-function-name">message</span>(FATAL_ERROR
    <span class="org-string">"No in source builds allowed. Create a separate build directory.</span>
<span class="org-string">    SOURCE_DIR=${</span><span class="org-variable-name">CMAKE_SOURCE_DIR</span><span class="org-string">}  BINARY_DIR=${</span><span class="org-variable-name">CMAKE_BINARY_DIR</span><span class="org-string">} "</span>)
<span class="org-keyword">endif</span>()
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org8e7afff" class="outline-3">
<h3 id="org8e7afff">CMake Variables</h3>
<div class="outline-text-3" id="text-org8e7afff">
<ul class="org-ul">
<li>You can set <code>cmake</code> variables when invoking cmake.
<ul class="org-ul">
<li>Usually you want to <code>cmake -DCMAKE_BUILD_TYPE=&lt;Type&gt;</code> where <code>&lt;Type&gt;</code> is:
<ul class="org-ul">
<li><code>Debug</code> - compile with debugging options enabled (<code>-g</code> for <code>gcc</code>)</li>
<li><code>Release</code> - compile with optimizations enables (<code>-O3</code> for <code>gcc</code>)</li>
<li>There are other release types as well</li>
</ul></li>
<li>If you don't specify a build type you get no additional compile flags</li>
<li><p>
I typically use the following code to have the build type default to <code>Debug</code> if not otherwise specified
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-keyword">if</span>(NOT CMAKE_BUILD_TYPE)        <span class="org-comment"># If no build type is set, set one</span>
  <span class="org-function-name">set</span>(CMAKE_BUILD_TYPE <span class="org-string">"Debug"</span> CACHE STRING <span class="org-string">"Type of build."</span> FORCE)
<span class="org-keyword">endif</span>()
</pre>
</div></li>
</ul></li>
<li>Since <code>cmake</code> generates Makefiles, you do not typically need to rerun <code>cmake</code>.
<ul class="org-ul">
<li>Even if you modify CMakeLists.txt, the Makefiles will invoke CMake automatically</li>
</ul></li>
<li>When debugging CMake problems, it can sometimes be helpful to completely delete the contents of the build directory and
regenerate everything from scratch</li>
</ul>
</div>
</div>

<div id="outline-container-orgb8d6042" class="outline-3">
<h3 id="orgb8d6042">Important CMake Concepts</h3>
<div class="outline-text-3" id="text-orgb8d6042">
<dl class="org-dl">
<dt>generation</dt><dd>Since CMake is a build-system generator (we are using <code>make</code> as the build system), it
is generating build files.
<ul class="org-ul">
<li>This means that you are actually using CMake Code to Generate Makefile Code to Compile C++ Code</li>
</ul></dd>
<dt>target</dt><dd>This is anything that will ultimately be created by the build system
<ul class="org-ul">
<li>For example: executables and libraries</li>
<li>When generating Makefiles, targets correspond to makefile targets
<ul class="org-ul">
<li>For example if you <code>add_executable(hello myworld.cpp)</code> then <code>hello</code> is a target and it can be built specifically by using <code>make hello</code></li>
</ul></li>
</ul></dd>
<dt>properties</dt><dd>various entities in CMake have properties that can be set
<ul class="org-ul">
<li>For targets, you can set properties using functions that begin with <code>target_set</code>
<ul class="org-ul">
<li><code>target_set_include_directories(targetname list_of_directories_where_include_files_are_found)</code></li>
<li><code>target_set_compile_options()</code></li>
<li><code>target_link_libraries(target lib1target lib2target)</code> a bit of a misnomer (it should really be called <code>target_link_target</code>) this
will not only link libraries lib1target and lib2target into <code>target</code> but also add their include paths and some other options
to target 
For example, if lib1target has include files in <code>/home/user/include</code>, <code>targetname</code> will be able to include those files as well.
<ol class="org-ol">
<li>Directory vs Local
<ul class="org-ul">
<li>CMake commands starting with <code>add</code> (such as <code>add_compile_options</code> generally apply to all CMake files in the current directory
or any sub directories. (They technically set properties on these directories)</li>
<li>CMake commands starting with <code>target</code> apply only to the target that is specified.  They can optionally be transferred to other
targets using <code>target_link_libraries</code></li>
<li><p>
Modern CMake Best practices favor using <code>target</code> level properties
</p>
<ul class="org-ul">
<li>Allows finer control</li>
<li>Passing on these options to dependencies with <code>target_link_libraries</code> means that when executable target_a depends on library_X which depends on library_Y which</li>
</ul>
<p>
depends on library_Z, <code>target_a</code> is compiled with all the necessary include file paths and library paths just by doing <code>target_link_libraries(target_a library_X)</code>
</p></li>
</ul></li>
</ol></li>
</ul></li>
</ul></dd>
</dl>
</div>
</div>
<div id="outline-container-orgda73c50" class="outline-3">
<h3 id="orgda73c50">Basic CMake Syntax</h3>
<div class="outline-text-3" id="text-orgda73c50">
<ol class="org-ol">
<li><code>${VARIABLE}</code> gets the value of a variable. This is a direct-string replacement
<ul class="org-ul">
<li>In most project, you want to avoid variables in <code>CMake</code> as much as possible and instead list files directly</li>
</ul></li>
<li>Functions in cmake can have a type of named argument, usually in capital letters.
So for example <code>message(FATAL_ERROR "The value of VARIABLE is ${VARIABLE}")</code>  will cause
a fatal cmake error and print <i>The value of VARIABLE is &lt;variable value here&gt;</i>.  (this is a decent cmake debugging technique.
message(WARNING "The value of VARIABLE is ${VARIABLE}")~  will just print a warning</li>
</ol>
</div>
</div>


<div id="outline-container-org2e567a5" class="outline-3">
<h3 id="org2e567a5">Dependencies</h3>
<div class="outline-text-3" id="text-org2e567a5">
<ul class="org-ul">
<li>If you ever get an error about <code>find_package</code> could not find <code>X</code> then this likely means you are missing a dependency
<ul class="org-ul">
<li>If you are lucky, that package might be available for <code>Ubuntu</code> and you can install it</li>
<li>If using ROS2, you can use <code>rosdep install --from-paths src --ignore-src -r -y</code> to install all dependencies of all packages in the source space</li>
</ul></li>
<li>You may occasionally encounter C++ packages that are not ROS packages and are not distributed with Ubuntu, meaning that you will need to compile them yourself</li>
<li>Due to the popularity of CMake, there is a good chance that this project will be using CMake as it's build system</li>
<li>By specifying <code>-DCMAKE_PREFIX_PATH=/home/user/location_where_to_install</code> and <code>-DCMAKE_INSTALL_PREFIX=/home/user/location_where_to_install</code> you are able to
<ul class="org-ul">
<li>Compile the package(s) you want</li>
<li>Install it to the location you want (<code>-DCMAKE_INSTALL_PREFIX</code> tells CMake to treat the specified path as the base location for all installations rather than the default (which is <code>/</code>) 
without needing root privileges or affecting the rest of your system</li>
<li>Use the installed package in other CMake packages (<code>-DCMAKE_PREFIX_PATH</code> tells CMake to treat the specified directory as if it were <code>/</code> when looking for files)</li>
</ul></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgfffa451" class="outline-2">
<h2 id="orgfffa451">Useful compile options</h2>
<div class="outline-text-2" id="text-orgfffa451">
</div>
<div id="outline-container-org6254e92" class="outline-3">
<h3 id="org6254e92">Local vs Global</h3>
<div class="outline-text-3" id="text-org6254e92">
<p>
In <code>CMake</code> you can set options for the compilation both globally and on a per-target level.
</p>
<ul class="org-ul">
<li>The advantage of setting options globally is that they are used for all targets and can be changed in one place.</li>
<li>The advantage of setting options locally is that you can use different options for different targets. Additionally,
the options can be passed on to targets that depend on the existing target.</li>

<li>There is some debate about whether setting compiler options and flags globally or locally is best. The <code>CMake</code> community (in my view)
favors the local approach, whereas ROS favors the global approach.</li>
</ul>
</div>
<details id="orgdfb3022"><summary class="header-4">A Compromise Approach</summary>
<div class="outline-text-4" id="text-orgdfb3022">
<ul class="org-ul">
<li>One compromise is to create a CMake target (call it <code>options_target</code>) with no source files, that just carries the compiler options.
<ul class="org-ul">
<li>By linking your targets to <code>options_target</code> with <code>target_link_libraries</code>, they inherit all options provided to <code>options_target</code></li>
<li>This way you have not defined anything globally (so different targets can have different options if needed), but all options
commonly used are defined in the same place.</li>
</ul></li>
</ul>
</div>
</details>
</div>

<div id="outline-container-org6a6cd95" class="outline-3">
<h3 id="org6a6cd95">C++ Standard</h3>
<div class="outline-text-3" id="text-org6a6cd95">
<p>
Setting the C++ standard has its own syntax in CMake. This is because every compiler has different options, but CMake is cross-platform
and provides a common standard-setting method across all compilers.
</p>
<ul class="org-ul">
<li>In advanced usage, CMake can compute the standard needed, given particular
language features that are desired.</li>
</ul>
</div>
<div id="outline-container-org6967f79" class="outline-4">
<h4 id="org6967f79">Locally (Per-Target)</h4>
<div class="outline-text-4" id="text-org6967f79">
<ul class="org-ul">
<li><p>
To set the standard for a given target
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-comment"># use c++17 when compiling targetName</span>
<span class="org-function-name">target_compile_features</span>(targetName PUBLIC cxx_std_17)
<span class="org-comment"># don't use gnu extensions</span>
<span class="org-function-name">set_target_properties</span>(targetName PROPERTIES CXX_EXTENSIONS OFF) 
</pre>
</div>
<ul class="org-ul">
<li><code>PUBLIC</code> means the features are used by the target and anything that depends on it</li>
<li>Other possibilities are <code>PRIVATE</code> which means just use the flags directly for the target not dependencies
and <code>INTERFACE</code> which means just used by dependencies but not the target itself</li>
<li>In other words, <code>PUBLIC = PRIVATE + INTERFACE</code></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgda44306" class="outline-4">
<h4 id="orgda44306">Globally (all targets)</h4>
<div class="outline-text-4" id="text-orgda44306">
<ul class="org-ul">
<li><p>
These settings can also be done globally.
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">set</span>(CMAKE_CXX_STANDARD 17)
<span class="org-function-name">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)
<span class="org-function-name">set</span>(CMAKE_CXX_EXTENSIONS OFF)
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org089d7b9" class="outline-4">
<h4 id="org089d7b9">Standards And ROS</h4>
<div class="outline-text-4" id="text-org089d7b9">
<ul class="org-ul">
<li>Technically ROS 2 only supports C++17</li>
<li>However, the compiler that ships with <code>Ubuntu 22.04</code> mostly supports <code>C++20</code> fully and ROS humble is officially supported on Ubuntu 22.04</li>
<li>C++ standards are very backwards compatible (as in older C++ code will usually compile with a newer standard enabled)</li>
<li>We will use C++17 in this class</li>
<li>C++20 came out in 2020, and you may experiment with it if you would like to.
<ul class="org-ul">
<li>Some key features of C++20 are:
<ul class="org-ul">
<li>Concepts (which will benefit you without even needing to know what they are!)</li>
<li>Modules (which is not enabled with just C++20 as it is still not fully implemented/tested in <code>gcc</code>)</li>
<li>Ranges (this standard makes working with <code>vectors</code> and <code>algorithms</code> much easier and more intuitive)</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org86510c1" class="outline-3">
<h3 id="org86510c1">Compile Options</h3>
<div class="outline-text-3" id="text-org86510c1">
</div>
<div id="outline-container-orgb07ad4f" class="outline-4">
<h4 id="orgb07ad4f">Locally (Per-Target)</h4>
<div class="outline-text-4" id="text-orgb07ad4f">
<ul class="org-ul">
<li>Use <code>target_compile_options(target -Wall -Wextra)</code> to add flags (in this case <code>-Wall -Wextra</code>) to the build</li>
</ul>
</div>
</div>
<div id="outline-container-orgcdd7ff9" class="outline-4">
<h4 id="orgcdd7ff9">Globally (all targets)</h4>
<div class="outline-text-4" id="text-orgcdd7ff9">
<ul class="org-ul">
<li>Global compile options are added with <code>add_compile_options(-Wall -Wextra)</code> (<code>-Wall -Wextra</code> in this case).</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org29d77e2" class="outline-2">
<h2 id="org29d77e2">Relationship with ament and colcon</h2>
<div class="outline-text-2" id="text-org29d77e2">
<ul class="org-ul">
<li><code>colcon</code> is a build tool and can compile projects written with multiple build systems</li>
<li><code>colcon</code> can automatically detect and compile plain CMake projects based on the presence of a <code>CMakeLists.txt</code>
<ul class="org-ul">
<li>A <code>package.xml</code> is optional, but can be included to provide dependency information to <code>colcon</code> to ensure the packages in the
workspace are compiled in the correct order</li>
<li>such a package should specify <code>cmake</code> as the <code>&lt;export&gt;&lt;build_type&gt;</code>, rather than <code>ament_cmake</code></li>
</ul></li>
<li>An <a href="https://docs.ros.org/en/humble/How-To-Guides/Ament-CMake-Documentation.html">ament_cmake</a> package is actually just a <code>CMakeLists.txt</code> file that happens to call <code>ament_cmake</code> functions</li>
<li>It is possible to invoke <code>cmake</code> directly on an <code>ament_cmake_ package rather than using =colcon</code></li>
<li><p>
The <code>ament</code> functions make it easy to generate custom interface types and also simplifies handling of <code>ROS 2</code> packages
</p>
<ul class="org-ul">
<li>Lets try it!</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">mkdir -p ws/src
<span class="org-builtin">cd</span> ws/src
ros2 pkg create --build-type ament_cmake testpkg
<span class="org-builtin">cd</span> ..
mkdir build
<span class="org-builtin">cd</span> build
cmake ../src/testpkg
make <span class="org-comment-delimiter"># </span><span class="org-comment">nothing will happen since we didn't add any files</span>
</pre>
</div></li>
<li><p>
Ament provides convenience functions for library installation:
</p>
<div class="org-src-container">
<pre class="src src-cmake">
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org320d6d0" class="outline-3">
<h3 id="org320d6d0">Installation of ament_libraries</h3>
<div class="outline-text-3" id="text-org320d6d0">
<ul class="org-ul">
<li><code>ament</code> makes it easier to install libraries than standard cmake</li>
<li><p>
After creating the libraries call
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">ament_export_targets</span>(my_library-targets HAS_LIBRARY_TARGET)
<span class="org-function-name">ament_export_dependencies</span>(dependency_of_library)
<span class="org-function-name">install</span>(DIRECTORY include/ DESTINATION include)
<span class="org-function-name">install</span>(TARGETS my_library EXPORT my_library-targets)
</pre>
</div></li>
<li>See <a href="https://docs.ros.org/en/humble/How-To-Guides/Ament-CMake-Documentation.html">Ament Guide</a> for more information</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd1386a8" class="outline-2">
<h2 id="orgd1386a8">ROS IDL Generation</h2>
<div class="outline-text-2" id="text-orgd1386a8">
<ul class="org-ul">
<li>ROS provides custom cmake functions for generating messages, services, and actions.</li>
<li>Everything related to IDL in ROS is in the <a href="https://github.com/ros2/rosidl">rosidl</a> repository
<ul class="org-ul">
<li>In particular <a href="https://github.com/ros2/rosidl/rosidl_cmake">rosidl_cmake</a> contains the CMake functionality (which is documented inside the source files)</li>
<li>The <code>package.xml</code> must contain <code>&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</code></li>
</ul></li>
<li>The package is for generating code from IDL files (e.g. <code>.srv</code>, <code>.msg</code>, and <code>.action</code>) files
is called <code>rosidl_default_generators</code>.
<ul class="org-ul">
<li>This package includes code for generating code from ROS IDL files in several default programming languages (e.g., Python, C++).</li>
</ul></li>
<li>After making <code>rosidl_default_generators</code> available, the next step is to generate the code using <code>rosidl_generate_interfaces</code></li>
<li><code>rosidl_generate_interfaces(${PROJECT_NAME} msgfiles... servicefiles...)</code>
<ul class="org-ul">
<li>By default, this will create a library named <code>${PROJECT_NAME}</code>, which is what the library must be named in order to work</li>
<li>However, it also creates a <code>cmake</code> target named <code>${PROJECT_NAME}</code>, so this call will fail if you have another cmake target
(such as a node) with the same name as your project</li>
<li>Instead, you can call this as <code>rosidl_generate_interfaces(&lt;any_name_you_want_here&gt; msgfiles... servicefiles... LIBRARY_NAME ${PROJECT_NAME})</code>
<ul class="org-ul">
<li>Here, the library will still have the proper name (based on <code>${PROJECT_NAME}</code>), but the name of the target can be any valid CMake target name</li>
</ul></li>
</ul></li>
<li>The target created by <code>rosidl_generate_interaces</code> is a "utility" target and cannot be used in <code>target_link_libraries</code>
<ul class="org-ul">
<li>To get a target suitable for use with <code>target_link_libraries</code> call <a href="https://github.com/ros2/rosidl/blob/rolling/rosidl_cmake/cmake/rosidl_get_typesupport_target.cmake">rosidl_get_typesupport_target.cmake</a></li>
<li><code>rosidl_get_type_support_target(&lt;OUTVAR&gt; &lt;target&gt; "string")</code>
<ul class="org-ul">
<li><code>&lt;OUTVAR&gt;</code> is the name of a cmake variable for storing the target name</li>
<li><code>&lt;target&gt;</code> is the name of the target created by <code>rosidl_generate_interfaces</code></li>
<li>"string" this should be <code>"rosidl_typesupport_cpp"</code> to get the typesupport library for C++.</li>
</ul></li>
</ul></li>
<li>The value stored in the <code>&lt;OUTVAR&gt;</code> from the <code>rosidl_get_type_support_target</code> call can be referenced when using <code>target_link_libraries</code></li>
<li><p>
Here is a complete example:
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">rosidl_generate_interfaces</span>(myservices <span class="org-string">"srv/ThisService.srv"</span> LIBRARY_NAME ${<span class="org-variable-name">PROJECT_NAME</span>})
<span class="org-function-name">rosidl_get_typesupport_target</span>(cpp_typesupport_target myservices <span class="org-string">"rosidl_typesupport_cpp"</span>)
<span class="org-function-name">ament_export_dependencies</span>(rosidl_default_runtime)
<span class="org-function-name">add_executable</span>(mynode myfile.cpp)
<span class="org-function-name">target_link_libraries</span>(mynode ${<span class="org-variable-name">cpp_typesupport_target</span>})
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org7ed96f0" class="outline-2">
<h2 id="org7ed96f0">Types of build</h2>
<div class="outline-text-2" id="text-org7ed96f0">
<ul class="org-ul">
<li>With <code>colcon</code> you can create three types of installation:
<ul class="org-ul">
<li>The default: all build files are copied to the install space and all packages have their own sub-folder</li>
<li>This keeps packages isolated for easier debugging, but it also means that the PATH's needed to run
your ROS program become longer (need a new PATH entry per project)</li>
<li><code>--merge-install</code>: Everything is copied, but they are all installed to a common root
<ul class="org-ul">
<li>Then, only some locations in the <code>install space</code> need to be in your path</li>
</ul></li>
<li><code>--symlink-install</code>: This option allows you to directly edit python files in the source space
and have the changes take effect immediately in the install space without re-running colcon
<ul class="org-ul">
<li>For C++ you need to compile after every change you make anyway, so this option is not useful.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org35b39ac" class="outline-2">
<h2 id="org35b39ac">CMake Practices</h2>
<div class="outline-text-2" id="text-org35b39ac">
<ol class="org-ol">
<li>All projects should include, at a minimum, the following compile flags:
<ul class="org-ul">
<li><code>-Wall</code> Enable all warnings</li>
<li><code>-Wextra</code> Enable extra warnings</li>
<li><code>-Wpedantic</code> conform to the C++ standard</li>
<li>ROS 2 automatically adds these options to the <code>CMakeLists.txt</code> template it generates!</li>
</ul></li>

<li>When not using <code>colcon</code> create a build directory and use <code>cmake</code> from that directory (out of source build).
<ul class="org-ul">
<li>Don't run <code>cmake</code> in a directory that contains code, it will make a mess</li>
</ul></li>

<li><p>
To set C++ version options globally
</p>
<pre class="example">
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)
</pre>
<ul class="org-ul">
<li>Setting using <code>set(CMAKE_CXX_STANDARD 17)</code> is still globally applied but it also is compiler independent</li>
</ul></li>

<li>Don't use <code>GLOB</code> to find files (I didn't discuss this but you will find it on many websites).
<ul class="org-ul">
<li>Some examples use <code>file(GLOB *.cpp)</code> to find all source files</li>
<li>Since this code executes only when CMake generates the build files, new source files will not be detected</li>
<li>The proper way to include files for compilation is to explicitly record each file</li>
</ul></li>

<li>Don't directly set <code>CMAKE_CXX_FLAGS</code> or <code>CMAKE_C_FLAGS</code> (I didn't discuss here there is a lot information out there about these)
<ul class="org-ul">
<li>This can overwrite important settings set elsewhere</li>
<li>It globally changes the compile flags for every project</li>
<li>If you are not careful it is not platform independent</li>
</ul></li>

<li>Don't make a hierarchy of CMakeLists.txt files in each sub-directory
<ul class="org-ul">
<li>This used to be best practice for CMake, but now it is better to do everything for a project in a top-level CMakeLists.txt</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orgfb07ef6" class="outline-2">
<h2 id="orgfb07ef6">Build Process as Directed Acyclic Graph</h2>
<div class="outline-text-2" id="text-orgfb07ef6">
<ol class="org-ol">
<li>When compiling code, there are often items that depend on other items:
<ul class="org-ul">
<li>For example, <code>main.cpp</code> may call a function defined in <code>library.cpp</code></li>
<li>If you change <code>library.cpp</code>, you need to recompile <code>main.cpp</code> also
<ul class="org-ul">
<li>However, if <code>main.cpp</code> changes, <code>library.cpp</code> does not care</li>
</ul></li>
</ul></li>
<li>Dependencies can be viewed as Directed Acyclic Graph (DAG)
<ul class="org-ul">
<li>Each file is a node in the graph</li>
<li>If B depends on A, then an edge exists from A to B</li>
<li>If a node changes, follow the arrows and compile everything along all paths</li>
<li>Although technically you could create circular dependencies in C++ you should avoid doing this
at all costs.
<ul class="org-ul">
<li>Adds complexity and brittleness to the build process</li>
<li>If A depends on B and B depends on A, then chances are A and B should actually be one unit</li>
<li>Alternatively, create a new dependency C that both B and A depend on</li>
</ul></li>
</ul></li>
<li><code>make</code> is a tool that reads a description of your project and the file dependencies and compiles it
<ul class="org-ul">
<li>You tell it the DAG describing the dependencies and only what is necessary gets compiled</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org050d0ca" class="outline-2">
<h2 id="org050d0ca">Cross Compilation</h2>
<div class="outline-text-2" id="text-org050d0ca">
<ul class="org-ul">
<li>Cross-compilation is the process of compiling code for one system on a different (and incompatible) system
<ul class="org-ul">
<li>For example, compiling code meant to run on a raspberry pi on your PC
<ul class="org-ul">
<li>This is hugely advantageous because compilation is significantly faster on a modern PC than on a raspberry pi (seconds versus hours).</li>
</ul></li>
</ul></li>
<li>To specify a cross-compiler, use <code>cmake -DCMAKE_TOOLCHAIN_FILE=&lt;toolchain&gt;</code>, where <code>&lt;toolchain&gt;</code> is a special cmake file
that is used to tell <code>cmake</code> about an alternative compiler</li>
<li>Since a <code>toolchain</code> file creates settings that are created really early in the <code>cmake</code> invocation, it must be set
when calling <code>cmake</code>: it will not have the desired effect if set from within your <code>CMakeLists.txt</code></li>
<li>I have provided a <code>cmake</code> <a href="./raspi-toolchain.cmake">toolchain file</a> to allow you to cross-compile for the raspberry pi.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd55453e" class="outline-2">
<h2 id="orgd55453e">ROS 1 and Catkin</h2>
<div class="outline-text-2" id="text-orgd55453e">
<ul class="org-ul">
<li>These notes are left for reference in case you encounter a ROS 1 project.</li>
<li><code>catkin_make</code>, <code>catkin_make_isolated</code>, and <code>catkin tools</code> are the ROS 1 build tools</li>
<li><code>colcon</code>, however, can also build ROS 1 packages and that is what is recommended</li>
<li>All ROS 1 packages, however, use <code>catkin</code> CMake files which follow a specific form</li>
<li>One big difference between ROS 1 and ROS 2 is that <code>ament_cmake</code> tries to hew much more
closely to standard <code>CMake</code> files than <code>ROS 1</code> did.</li>
</ul>
</div>
<div id="outline-container-orgd6649ab" class="outline-3">
<h3 id="orgd6649ab">A Deep Dive into a Catkin CMakeLists.txt</h3>
<div class="outline-text-3" id="text-orgd6649ab">
<ul class="org-ul">
<li><p>
Preamble, same as a normal
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-comment"># minimum cmake Version 3.9, rather outdated</span>
<span class="org-function-name">cmake_minimum_required</span>(VERSION 3.9)

<span class="org-comment"># name of project, must match package.xml</span>
<span class="org-function-name">project</span>(my_project)
</pre>
</div></li>

<li>Notice that catkin is found just like any other package would be (because a main component of 
catkin is a cmake code)</li>
<li><p>
The COMPONENTS part is because catkin sets everythign up so that ROS packages can be brought in
as if they were a piece of the catkin cmake package
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">find_package</span>(catkin REQUIRED COMPONENTS roscpp)
</pre>
</div></li>

<li><p>
Next, find other packages that are non-ros, just as you would in a regular cmake file
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">find_package</span>(Boost REQUIRED COMPONENTS system)
</pre>
</div></li>
<li><p>
For ROS messages, services, etc to work, C++/python files encapsulating those messages must
be created at compile time (that is, when you run make).  These functions are provided by catkin
to build the messages files into python and C++ code. This part 
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">add_message_files</span>()
<span class="org-function-name">add_service_files</span>()
<span class="org-function-name">add_action_files</span>()
<span class="org-function-name">generate_messages</span>()
<span class="org-function-name">generate_dynamic_reconfigure_options</span>()
</pre>
</div></li>

<li><p>
catkin_package is used to let other packages know how to use your package as a dependency
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-comment">## INCLUDE_DIRS: use if package contains header files</span>
<span class="org-comment">## LIBRARIES: libraries created here that dependent projects need</span>
<span class="org-comment">## CATKIN_DEPENDS: catkin_packages dependent projects need</span>
<span class="org-comment">## DEPENDS: system dependencies of this project that dependent projects also need</span>
<span class="org-function-name">catkin_package</span>(
<span class="org-comment">#  INCLUDE_DIRS include</span>
<span class="org-comment">#  LIBRARIES tmp</span>
<span class="org-comment">#  CATKIN_DEPENDS other_catkin_pkg</span>
<span class="org-comment">#  DEPENDS system_lib</span>
)
</pre>
</div>
<ul class="org-ul">
<li>The <code>INCLUDE_DIRS</code> is where your package's header files are stored. This let's other catkin packages use these header files</li>
<li>The <code>LIBRARIES</code> are for anything you created with <code>add_library</code> that you want other catkin_packages to be able to use</li>
<li>The <code>CATKIN_DEPENDS</code> is for any catkin package (added to the <code>find_package(catkin REQUIRED COMPONENTS ...)</code> line that
packages that use your project need</li>
<li>The <code>DEPENDS</code> line is for any non-catkin package (found via <code>find_package</code>) that a project that uses your project needs</li>
</ul></li>

<li><p>
Rather than using <code>target_include_directories</code> on individual targets, <code>catkin</code> sets include directories that are used
by all targets in your package globally. The <code>${catkin_INCLUDE_DIRS}</code> variable is populated with directories set in <code>catkin_package</code>
in all of the packages found by <code>find_package(catkin REQUIRED COMPONENTS)</code>
</p>
<pre class="example">
include_directories(
include
 ${catkin_INCLUDE_DIRS}
)
</pre></li>

<li>Targets (i.e., libraries and executables) are added as usual</li>
<li>Target names are always prefixed by ${PROJECT_NAME} to avoid name conflicts.
<ul class="org-ul">
<li><code>${PROJECT_NAME}</code> is a CMAKE variable that is filled in by the call to <code>project()</code> at the beginning of the file</li>
<li><code>catkin_make</code> actually turns all the packages in your workspace into a single giant
cmake package, and a single package can't have duplicate target names</li>
<li>If you force the users to use either <code>catkin_make_isolated</code> or <code>catkin_tools</code> this usage is unnecessary</li>
</ul></li>
<li>In the model presented here, the library name is the same as the catkin_package name. Many times 
there is a 1-1 correspondance between a C++ library and a ROS package, but there need not be.</li>
<li><p>
If setting flags and standards globally, you would use <code>target_compile_features</code> and <code>target_compile_options</code>
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">add_library</span>(${<span class="org-variable-name">PROJECT_NAME</span>} src/${<span class="org-variable-name">PROJECT_NAME</span>}/tmp.cpp)
<span class="org-function-name">target_compile_features</span>(${<span class="org-variable-name">PROJECT_NAME</span>} PUBLIC cxx_std_17)
<span class="org-function-name">target_compile_options</span>(${<span class="org-variable-name">PROJECT_NAME</span>} -Wall -Wextra)
</pre>
</div></li>

<li>This line says that your library (called <code>${PROJECT_NAME}</code>) depends on (i.e., will be compiled after) all the targets (i.e., libraries)
that the current package exports (via <code>catkin_package</code>) and targets required by anything found with <code>find_package(catkin REQUIRED COMPONENTS)</code>.</li>
<li><p>
It also ensures that any messages/services that are required are built first
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">add_dependencies</span>(${<span class="org-variable-name">PROJECT_NAME</span>} ${${<span class="org-variable-name">PROJECT_NAME</span>}_EXPORTED_TARGETS} ${<span class="org-variable-name">catkin_EXPORTED_TARGETS</span>})
</pre>
</div></li>

<li>Adding an executable (e.g., a node) is similar to adding a library, but includes a few extra lines.</li>
<li>I recommend grouping these lines together for all nodes that you add</li>
<li>The CMake target name is prefixed with <code>${PROJECT_NAME}</code> to avoid conflicts with other packages.</li>
<li>The actual name of the node is changed to remove with <code>${PROJECT_NAME}</code>  prefix with <code>set_target_properties</code></li>
<li>The node is made to depend on all the imported <code>catkin</code> packages and libraries so it is compiled after them.</li>
<li><p>
The executable is also linked against any libraries that were exported by the catkin_packages we have included, and any other non-catkin libraries we need
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">add_executable</span>(${<span class="org-variable-name">PROJECT_NAME</span>}_node src/tmp_node.cpp)
<span class="org-function-name">set_target_properties</span>(${<span class="org-variable-name">PROJECT_NAME</span>}_node PROPERTIES OUTPUT_NAME node PREFIX <span class="org-string">""</span>)
<span class="org-function-name">add_dependencies</span>(${<span class="org-variable-name">PROJECT_NAME</span>}_node ${${<span class="org-variable-name">PROJECT_NAME</span>}_EXPORTED_TARGETS} ${<span class="org-variable-name">catkin_EXPORTED_TARGETS</span>})
<span class="org-function-name">target_link_libraries</span>(${<span class="org-variable-name">PROJECT_NAME</span>}_node ${<span class="org-variable-name">catkin_LIBRARIES</span>})
</pre>
</div></li>
<li>Add libraries from system dependencies (i.e., those found with <code>find_package(Library)</code>) to <code>target_link_libraries</code></li>
<li>Add local compile options and features with <code>target_compile_features</code> and <code>target_compile_options</code></li>

<li>The installation phase is usually not used during development but becomes important if, for example, you
wanted to created a binary version of your package so other people could use it without needing to compile your code.</li>

<li><p>
To install python scripts, cmake copies them from the source directory to an installation directory
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">install</span>(PROGRAMS
scripts/my_python_script
DESTINATION ${<span class="org-variable-name">CATKIN_PACKAGE_BIN_DESTINATION</span>}
)
</pre>
</div></li>

<li><p>
To install your nodes list them on the line below:
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">install</span>(TARGETS ${<span class="org-variable-name">PROJECT_NAME</span>}_node
  RUNTIME DESTINATION ${<span class="org-variable-name">CATKIN_PACKAGE_BIN_DESTINATION</span>}
)
</pre>
</div></li>

<li><p>
To install libraries list them below
</p>
<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">install</span>(TARGETS ${<span class="org-variable-name">PROJECT_NAME</span>}
  ARCHIVE DESTINATION ${<span class="org-variable-name">CATKIN_PACKAGE_LIB_DESTINATION</span>}
  LIBRARY DESTINATION ${<span class="org-variable-name">CATKIN_PACKAGE_LIB_DESTINATION</span>}
  RUNTIME DESTINATION ${<span class="org-variable-name">CATKIN_GLOBAL_BIN_DESTINATION</span>}
)
</pre>
</div></li>

<li>The header files for your library must also be explicitly installed.</li>
<li><p>
The version in <code>catkin_pkg</code> only copies files with a <code>.h</code> extension.
I remove this restriction as its unnecessary and I end <code>C++</code> headers with <code>.hpp</code> 
</p>
<pre class="example">
install(DIRECTORY include/${PROJECT_NAME}/
  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
)
</pre></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org5c1043a" class="outline-2">
<h2 id="org5c1043a">Resources</h2>
<div class="outline-text-2" id="text-org5c1043a">
<ul class="org-ul">
<li><a href="https://cmake.org/documentation/">Official Documentation</a>
<ul class="org-ul">
<li>Often the latest version has better documentation than earlier versions but is still applicable</li>
</ul></li>
<li><a href="https://cliutils.gitlab.io/modern-cmake/">Introduction to Modern CMake</a></li>
<li><a href="https://rix0r.nl/blog/2015/08/13/cmake-guide/">https://rix0r.nl/blog/2015/08/13/cmake-guide/</a></li>
<li><a href="https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/">https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/</a></li>
<li><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></li>
<li><a href="https://www.slideshare.net/DanielPfeifer1/cmake-48475415">https://www.slideshare.net/DanielPfeifer1/cmake-48475415</a></li>
<li><a href="https://kubasejdak.com/19-reasons-why-cmake-is-actually-awesome#4-cmake-allows-easy-external-project-download-and-incorporation">19 Reasons Why Cmake Is actually awesome</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p><p class="outline-2">Author: Matthew Elwin</p></p>
</div>
</body>
</html>
